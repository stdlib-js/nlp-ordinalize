{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isPlainObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport indexOf from '@stdlib/utils-index-of';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// VARIABLES //\n\nvar LANGUAGE_CODES = [ 'en', 'es', 'fin', 'fr', 'de', 'it', 'pt', 'swe' ];\nvar GRAMMATICAL_GENDERS = [ 'masculine', 'feminine' ];\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - options to validate\n* @param {string} [options.lang] - language code\n* @param {boolean} [options.suffixOnly] - boolean indicating whether to only return the suffix\n* @param {string} [options.gender] - grammatical gender (used if applicable; either 'masculine' or 'feminine')\n* @returns {(null|Error)} error object or null\n*\n* @example\n* var opts = {};\n* var options = {\n*     'lang': 'es'\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isPlainObject( options ) ) {\n\t\treturn new TypeError( format( '0kX2V,FD', options ) );\n\t}\n\tif ( hasOwnProp( options, 'lang' ) ) {\n\t\topts.lang = options.lang;\n\t\tif ( indexOf( LANGUAGE_CODES, opts.lang ) === -1 ) {\n\t\t\treturn new TypeError( format( '0kXLi', 'lang', LANGUAGE_CODES.join( '\", \"' ), opts.lang ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'suffixOnly' ) ) {\n\t\topts.suffixOnly = options.suffixOnly;\n\t\tif ( !isBoolean( opts.suffixOnly ) ) {\n\t\t\treturn new TypeError( format( '0kX2o,GE', 'suffixOnly', opts.suffixOnly ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'gender' ) ) {\n\t\topts.gender = options.gender;\n\t\tif ( indexOf( GRAMMATICAL_GENDERS, opts.gender ) === -1 ) {\n\t\t\treturn new TypeError( format( '0kXLi', 'gender', GRAMMATICAL_GENDERS.join( '\", \"' ), opts.gender ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isInteger } from '@stdlib/assert-is-integer';\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport validate from './validate.js';\n\n\n// MAIN //\n\n/**\n* Converts an integer to an ordinal string (e.g., `1st`, `2nd`, etc.).\n*\n* @param {(string|integer)} value - string or number to convert\n* @param {Object} [options] - options\n* @param {boolean} [options.suffixOnly=false] - boolean indicating whether to return only the suffix\n* @param {string} [options.lang='en'] - language code\n* @param {string} [options.gender='masculine'] - grammatical gender (used if applicable; either 'masculine' or 'feminine')\n* @throws {TypeError} must provide a string or integer\n* @returns {string} ordinal string or suffix\n*\n* @example\n* var out = ordinalize( '1' );\n* // returns '1st'\n*\n* @example\n* var out = ordinalize( '2' );\n* // returns '2nd'\n*\n* @example\n* var out = ordinalize( '21' );\n* // returns '21st'\n*\n* @example\n* var out = ordinalize( '1', { 'lang': 'de' } );\n* // returns '1.'\n*\n* @example\n* var out = ordinalize( '7', { 'lang': 'es' } );\n* // returns '7º'\n*/\nfunction ordinalize( value, options ) {\n\tvar suffix;\n\tvar last2;\n\tvar last;\n\tvar opts;\n\tvar err;\n\n\tif ( !isString( value ) && !isInteger( value ) ) {\n\t\tthrow new TypeError( format( '0kXLh', value ) );\n\t}\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tvalue = String( value );\n\tlast = value[ value.length-1 ];\n\tlast2 = value.slice( -2 );\n\n\tswitch ( opts.lang ) {\n\tcase 'fr':\n\t\tif ( value === '1' ) {\n\t\t\tsuffix = ( opts.gender === 'feminine' ) ? 're' : 'er';\n\t\t} else {\n\t\t\tsuffix = 'e';\n\t\t}\n\t\tbreak;\n\tcase 'de':\n\tcase 'fin':\n\t\tsuffix = '.';\n\t\tbreak;\n\tcase 'it':\n\tcase 'pt':\n\tcase 'es':\n\t\tif ( opts.gender === 'feminine' ) {\n\t\t\tsuffix = 'ª';\n\t\t} else {\n\t\t\tsuffix = 'º';\n\t\t}\n\t\tbreak;\n\tcase 'swe':\n\t\tif ( ( last2 !== '11' && last === '1' ) || ( last2 !== '12' && last === '2' ) ) {\n\t\t\tsuffix = ':a';\n\t\t} else {\n\t\t\tsuffix = ':e';\n\t\t}\n\t\tbreak;\n\tcase 'en':\n\tdefault:\n\t\tif ( last2 !== '11' && last === '1' ) {\n\t\t\tsuffix = 'st';\n\t\t} else if ( last2 !== '12' && last === '2' ) {\n\t\t\tsuffix = 'nd';\n\t\t} else if ( last2 !== '13' && last === '3' ) {\n\t\t\tsuffix = 'rd';\n\t\t} else {\n\t\t\tsuffix = 'th';\n\t\t}\n\t}\n\tif ( opts.suffixOnly ) {\n\t\treturn suffix;\n\t}\n\treturn value + suffix;\n}\n\n\n// EXPORTS //\n\nexport default ordinalize;\n"],"names":["LANGUAGE_CODES","GRAMMATICAL_GENDERS","validate","opts","options","isPlainObject","hasOwnProp","lang","indexOf","TypeError","format","join","suffixOnly","isBoolean","gender","ordinalize","value","suffix","last2","last","err","isString","isInteger","arguments","length","String","slice"],"mappings":";;srBA+BA,IAAIA,EAAiB,CAAE,KAAM,KAAM,MAAO,KAAM,KAAM,KAAM,KAAM,OAC9DC,EAAsB,CAAE,YAAa,YA0BzC,SAASC,EAAUC,EAAMC,GACxB,OAAMC,EAAeD,GAGhBE,EAAYF,EAAS,UACzBD,EAAKI,KAAOH,EAAQG,MAC2B,IAA1CC,EAASR,EAAgBG,EAAKI,OAC3B,IAAIE,UAAWC,EAAQ,QAAS,OAAQV,EAAeW,KAAM,QAAUR,EAAKI,OAGhFD,EAAYF,EAAS,gBACzBD,EAAKS,WAAaR,EAAQQ,YACpBC,EAAWV,EAAKS,aACd,IAAIH,UAAWC,EAAQ,WAAY,aAAcP,EAAKS,aAG1DN,EAAYF,EAAS,YACzBD,EAAKW,OAASV,EAAQU,QACgC,IAAjDN,EAASP,EAAqBE,EAAKW,SAChC,IAAIL,UAAWC,EAAQ,QAAS,SAAUT,EAAoBU,KAAM,QAAUR,EAAKW,SAGrF,KApBC,IAAIL,UAAWC,EAAQ,WAAYN,GAqB5C,CCpBA,SAASW,EAAYC,EAAOZ,GAC3B,IAAIa,EACAC,EACAC,EACAhB,EACAiB,EAEJ,IAAMC,EAAUL,KAAYM,EAAWN,GACtC,MAAM,IAAIP,UAAWC,EAAQ,QAASM,IAGvC,GADAb,EAAO,CAAA,EACFoB,UAAUC,OAAS,IACvBJ,EAAMlB,EAAUC,EAAMC,IAErB,MAAMgB,EAOR,OAHAD,GADAH,EAAQS,OAAQT,IACFA,EAAMQ,OAAO,GAC3BN,EAAQF,EAAMU,OAAQ,GAEbvB,EAAKI,MACd,IAAK,KAEHU,EADc,MAAVD,EACuB,aAAhBb,EAAKW,OAA0B,KAAO,KAExC,IAEV,MACD,IAAK,KACL,IAAK,MACJG,EAAS,IACT,MACD,IAAK,KACL,IAAK,KACL,IAAK,KAEHA,EADoB,aAAhBd,EAAKW,OACA,IAEA,IAEV,MACD,IAAK,MAEHG,EADgB,OAAVC,GAA2B,MAATC,GAA8B,OAAVD,GAA2B,MAATC,EACrD,KAEA,KAEV,MAED,QAEEF,EADc,OAAVC,GAA2B,MAATC,EACb,KACY,OAAVD,GAA2B,MAATC,EACpB,KACY,OAAVD,GAA2B,MAATC,EACpB,KAEA,KAGX,OAAKhB,EAAKS,WACFK,EAEDD,EAAQC,CAChB"}